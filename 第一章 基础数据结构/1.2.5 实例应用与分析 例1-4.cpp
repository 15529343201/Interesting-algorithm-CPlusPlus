//例1-4 如果发现一个单链表有环，如何找出环的起始位置?
//要找出环的起始位置，就需要分析链表的环的长度与链表长度之间有什么样的联系。
/*我们回顾判断链表是否有环的算法运行过程，又快慢两个指针p和q。p每次走一步，
q每次走两步，q的速度是p的两倍。假设链表的长度为L，链表起点到环的起点的距离
为a，环长度为r。同时假设快指针和慢指针在相遇的时候，慢指针在环内已经走了X步，
总共走了S步，那么快指针总共走了2S步(快指针速度是慢指针的两倍)。再相遇的时候
快指针一定已经走了n圈环形路线了，所以我们有
          2S=S+nr                 (1)
从(1)式可以得出S=nr.S是慢指针p所走过的总共的步数，他主要由两部分构成：链表起点
到环的起点之间的距离a和指针p在环内走的步数。所以
          S=a+X                   (2)
(2)式得到了慢指针的行走步数与环的起始位置之间的关系式。根据题目的条件，对式(2)
进行一系列的数学变形，得到
          a+X=nr=(n-1)r+r=(n-1)r+L-a   (3)
得出
          a=(n-1)r+L-a-X               (4)
由于(n-1)r+L-a表示的是相遇点的位置，且L-a等于环长度r，那么L-a-X表示相遇点继续前进
到达环起始位置的距离。所以式(4)体现的意思就是链表起点到环的起点的长度a与快慢指针
相遇点到环的起始位置的长度相等。*/
/*这一结论就是我们解决这道题目的理论基础。我们在让快慢指针相遇之后，将快指针重新
指向链表头部，同时让快指针q的速度变得与慢指针p相同，继续移动两个指针，每次移动一步，
当两个指针相遇时的结点就是链表环的起始位置。*/
/**************找出链表环的起始位置*****************/
Node* circleStart(Node *head)
{
	if(head==NULL)
		return false;
	Node *p,*q;              //设置跑步指针
	p=q=head;                //初始化指针为head
	while(q!=NULL && q->next!=NULL)
	{
		p=p->next;           //p每次移动一步
		q=q->next->next      //q每次移动两步
		if(p==q)
		{
			break;
		} 
	}
	if(p==q && p!=NULL)      //相遇且不为NULL则有环
	{
		q=head;              //快指针重新赋值
		while(p!=q)
		{
			p=p->next;       //继续移动直至相遇
			q=q->next; 
		}
		return p;            //返回相遇结点即为环起始位置 
	}
	else
	{
		return NULL;         //否则无环 
	} 
} 
